
The saver could store more events than the creation event and test events.
  o) file new
  o) file rename
  o) file delete
  o) move to different file
Also, saver could move to git repo for each kata to save disk space.
I think this will get more important if cyber-dojo gets more popular.

Moving to git storage for just the current events is doable.
The only really tricky bit is, eg, files being deleted.
To solve this I can use the same trick the differ uses.
For example, for a new test event
  o) move the .git dir to a /tmp dir
  o) delete *all* content in the dir (* and .*)
  o) move the /tmp .git dir back into the katas/ dir
  o) save all the files
  o) git add .
  o) git commit -m "#{index}"
This is obviously not concurrent-safe.
How can an unsync'd pair be made safe?

How do you get all the files back for a given commit index?
You could git checkout the index and then tar and compress
all the files into .tgz file.
You wouldn't need to erase the checked out files afterwards
if (as above) a git commit was always preceded by deleting the
dir's contents.
But there is a concurrency issue. So the checkout would need to
be to a /tmp dir.
  git checkout-index --all --force --prefix=/destination/path/
This checks out files from the index.
So it would need to be preceeded by a git checkout.
Again that has concurrency issues.
From 1.8.0 git clone can clone a specified branch/tag
  git clone --branch TAG --depth 1 REPO_URL
This is ok but what I really want is to get all the files for a tag
in a format that completely drops the git repo (with its .git dir).
Searching...
There is a git archive command. Has to be faster!
A git archive just creates raw files.
  $ git archive --output /tmp/X/index-files.zip #{INDEX} #{REPO_DIR}
These could then be put into a single json string.
You would need to get a dir listing.
Simpler would be to just use the .tgz file as the payload.
  $ git archive --prefix=#{KATA_ID}-#{INDEX}/ --output /tmp/#{KATA_ID}-#{INDEX}.tar.gz #{INDEX}
This still writes the tgz file which then has to be read.
There must be a way to read the tgz file directly into a variable (in Ruby).

  
