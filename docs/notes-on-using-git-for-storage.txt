
Using git for storage
---------------------

The current format of 23.event.json holding everything in one file.
Suppose a simple git repo held the files, and commit tag 23 would hold separate files.
Would lose 23.events.json's ability to store extra info, eg was a file truncated?

Would obviously save disk space.

The saver could then store more events than the creation event and test events.
  o) file new
  o) file rename
  o) file delete
  o) move to different file


Ensuring unsync'd pair failure is a no-op
-----------------------------------------
The browser maintains the index (eg 23) and that comes in with the [test] result.
There is a git repo in the kata's dir.
There is also a lock/ dir (which is in .gitignore)
  o) attempt file_create lock/23.tag (as empty dir)
  o) move the katas/ .git dir to a /tmp dir  (move not copy)
  o) delete *all* content in the dir including dot files (but not lock/)
  o) move the /tmp .git dir back into the katas/ dir
  o) save all the incoming files
  o) git add .
  o) git commit --allow-empty --message "#{index}" --quiet
The events.json file could be maintained as is and added to the .gitignore file?
The meta info (eg file truncation) could be stored in a json file?


What if the user has their own file called events.json ?
--------------------------------------------------------
Any "meta info" file clearly has this problem.
Put the incoming files into a subdir, eg src/
The stdout/stdout/status could go into the top-level dir
which would allow the user to have their own files called
stdout/stder/status.


Could the files could be sent from the browser already in .tgz format?
----------------------------------------------------------------------
Eg using an npm library such as archiver?
That would mean less bytes travelling across networks.
Then runner could perhaps use that format directly for a small speed up?
And saver could use it too.
Runner can modify the files; it returns {@created,@changed,@deleted}
Saver could be passed these @@@ args directly.
It could untar the main .tgz file and _then_ process
{@created,@changed,@deleted} _itself_ on top of the
untarred files. The git add, git commit, git tag.


How do you get all the files back for a given commit index?
-----------------------------------------------------------
This is needed for kata/edit (eg on a refresh).
Would also allow diff to work as it does now.
There is a git archive command, which can create tgz files.
Return tgz as the payload.
Here's how to create a tgz file.
  $ git archive --prefix=#{KATA_ID}-#{INDEX}/ --output /tmp/#{KATA_ID}-#{INDEX}.tar.gz #{INDEX}
There must be a way to read the tgz file directly into a variable (eg in Ruby)
so it can be put directly into the response payload.
